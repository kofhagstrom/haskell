module TaylorSeries where

-- computes the factorial of n (n!)
factorial' :: (Num a, Enum a) => a -> a
factorial' n = product [1..n]

-- repeats x infintely
repeat' :: t -> [t]
repeat' x = x : repeat' x

-- creates list of x:s of length n
replicate' :: Int -> a -> [a]
replicate' n x = take n $ repeat' x

-- computes x^y
power :: Num a => a -> Int -> a
power x y = product $ replicate' y x

-- evaluates the polynomial with coefficients coef at the point x
polynomial :: Num c => [c] -> c -> [c]
polynomial coef x = zipWith (curry (\c -> fst c * power x (snd c))) coef [0..]

-- computes the taylor series with coefficients generated by coefGenerator
taylorSeries :: (Num c, Num a, Enum a) => (a -> c) -> c -> [c]
taylorSeries coefGenerator = polynomial $ map coefGenerator [1..]

-- computes the expontential function
exponential :: Double -> [Double]
exponential = taylorSeries (\x -> x / factorial' x)

-- computes euler's number to nTerms precision
eulersNumber :: Int -> Double
eulersNumber nTerms = sum $ take nTerms (exponential 1)