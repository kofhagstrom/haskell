module TaylorSeries where

-- computes the factorial of n (n!)
factorial' :: (Num a, Enum a) => a -> a
factorial' n = product [1 .. n]

-- creates list of x's of length n
replicate' :: a -> Int -> [a]
replicate' x n = take n $ repeat x
  where
    repeat = \x -> x : repeat x

-- computes x^y
power :: Num a => a -> Int -> a
power x y = product $ replicate' x y

-- evaluates the polynomial with coefficients coef at the point x
polynomial :: Num c => [c] -> c -> [c]
polynomial coef x = zipWith (curry (\c -> fst c * power x (snd c))) coef [0 ..]

-- computes the taylor series with coefficients generated by coefGenerator
taylorSeries :: (Num c, Num a, Enum a) => (a -> c) -> c -> [c]
taylorSeries coefGenerator = polynomial $ map coefGenerator [1 ..]

-- computes the expontential function
exponential :: Double -> [Double]
exponential = taylorSeries (\x -> x / factorial' x)

-- computes euler's number to nTerms precision
eulersNumber :: Int -> Double
eulersNumber nTerms = sum $ take nTerms (exponential 1)